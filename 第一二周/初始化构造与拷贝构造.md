# 初始化构造函数的几种语法
### 构造函数初始值列表
语法形式为 
className(param): 成员(param)
```cpp
class Test {
    string name;
    int num;
public:
    Test(const string &s, int _num): name(s), num(_num) {}
};
```
### 委托构造函数
委托构造函数：指的是一个构造函数调用另一个构造函数来初始化
```cpp
class Test {
    string name;
    int num;
public:
    Test(const string &s, int _num): name(s), num(_num) {}
    Test(): Test("futu", 666) {} // 委托构造函数
};
```

### 转换构造函数
转换构造函数：一个构造函数只有一个 形参，那么它为类型转换提供了可能
```cpp
class Test {
    string name;
    int num;
public:
    Test(const string& s): name(s) {}
};
int main()
{
    string s = "1";
    Test t = s; // 发生隐式类型转换
}
```
禁止隐式类型转换，使用 explicit 关键字
```cpp
explicit Test(const string& s): name(s) {}
```

# 拷贝构造函数、拷贝赋值运算符、析构函数与三五法则
问题1：什么情况下调用了拷贝构造
```
1.将类对象作为实参传递给非引用类型的形参(值传递)
2.函数返回类型为非引用类型的类对象
3.列表初始化数组、聚合类（比如pair）
4.STL容器调用insert()、push()；反之emplace是直接构造
```

问题2：为什么拷贝构造函数的形参必须是引用，不是值传递【经典八股】
```cpp
假如，拷贝构造函数形参是 值传递；
调用拷贝构造函数时，会发生一个动作 【把实参拷贝一份传递给形参】
那么这个动作需要用哪个函数来完成呢？当然还是 【拷贝构造函数】
这样子就会无限递归调用了，就出错了

class Test {
public:
    Test(const Test & other) {} // 拷贝构造函数不加引用编译报错
};
```

问题3：拷贝赋值运算符函数 返回类型是 class T 还是 class T&
```cpp
Test& operator=(const Test& other);
记得，是 class T&
```

问题4：什么情况下调用 析构函数
```
1.变量离开作用域
2.类对象析构时，其成员被析构
3.STL容器、数组析构时，其存储的元素被析构
4.保存一个表达式计数结果的临时对象（右值）在语句执行完毕后，临时对象被析构
```

### 三五法则之三
#### 同时实现 拷贝构造函数、拷贝赋值运算符、析构函数
如果一个类需要定义，拷贝构造函数、拷贝赋值运算符、析构函数中的任意一个，
那么另外2个也应当提供自定义实现。因为假如一个类，编译器自动合成的【拷贝赋值析构】能满足需求的话（就是说成员里面没有指针，不需要管理内存）
那完全没必要去自己实现。假如需要实现其中任意一个，这就说明编译器自动合成的函数已经不能胜任工作了，那就该提供自定义实现了

### 赋值运算符  = 函数的正确编写守则【考虑自我赋值行为  obj = obj】
```
1.将一个对象自己赋值自己的情况，必须保证正确运行 （obj = obj）
2.赋值重载函数一般要做 析构 + 拷贝 两件事情
3.赋值函数的形参，应当先将其copy 一份到临时变量，再去 delete 原对象，再把临时变量赋值给原对象；
（如果省略第一步拷贝临时变量，当发生自己赋值自己的情况，delete 原对象把传递进来的形参也delete【同一个对象】，
既然被delete，那么赋值给原对象就出错）
```

