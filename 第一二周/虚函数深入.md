### 虚函数和纯虚函数的区别
定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

### 虚函数只能借助于指针或者引用来达到多态的效果。
虚函数必须实现，如果不实现，编译器将报错
```cpp
class A
{
public:
    virtual void foo()
    {
        cout<<"A::foo() is called"<<endl;
    }
};
class B:public A
{
public:
    void foo()
    {
        cout<<"B::foo() is called"<<endl;
    }
};
int main(void)
{
    A *a = new B();
    a->foo();   // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!
    return 0;
}
```

### 纯虚函数
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0:
`virtual void funtion1() = 0`
纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。

### 抽象类
（1）抽象类的定义： 称带有纯虚函数的类为抽象类。
（2）抽象类不能实例化。

### 虚析构函数
析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

### 虚函数与重载函数的关系
在一个派生类中重新定义基类的虚函数是函数重载的另一种形式，但它不同于一般函数重载。
当普通的函数重载时，其函数的参数或参数类型有所不同，函数的返回类型也可以不同。但是当重载一个虚函数时，也就是说在派生类中重新定义虚函数时，要求函数名、返回类型、参数个数、参数的类型和顺序与基类的虚函数原型完全相同。
如果仅仅返回类型不同，其余均相同，系统会给出错误信息；若仅仅函数名相同，而参数的个数、类型或顺序不同，系统将它作为普通的函数重载，这时虚函数的特性将丢失。 



### 虚函数表 [虚函数表](https://www.cnblogs.com/Mered1th/p/10924545.html)
虚函数表是指在每个包含虚函数的类中都存在着一个函数地址的数组。当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。
C++的编译器保证虚函数表的指针存在于对象实例中最前面的位置，这样通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。
```cpp
class Base {
public:
	virtual void f() { cout << "f()" << endl; }
	virtual void g() { cout << "g()" << endl; }
	virtual void h() { cout << "h()" << endl; }
};
int main()
{
	Base t;
	(     ((void(*)())*((int*)(*((int*)&t)) + 0))   )     (); // 通过实例对象的地址，得到了对象所有的类函数
	(     ((void(*)())*((int*)(*((int*)&t)) + 1))   )     ();
	(	  ((void(*)())*((int*)(*((int*)&t)) + 2))	)     ();
	return 0;
}
```
main 定义Base 类对象t，把 `&b` 转成` int *` ，
取得虚函数表的地址vtptr就是：`(int*)(&t)`，然后再解引用并强转成 `int *`
得到第一个虚函数的地址，也就是`Base::f()`即`(int*)(*((int*)&t))`，那么，第二个虚函数`g()`的地址就是`(int*)(*((int*)&t)) + 1`，依次类推。

### 单继承 + 虚函数表
#### 派生类 未覆盖 基类虚函数
1）虚函数按照其声明顺序放于表中。
2）父类的虚函数在子类的虚函数前面。
```cpp
class Base {
public:
	virtual void f() { cout << "f()" << endl; }
	virtual void g() { cout << "g()" << endl; }
	virtual void h() { cout << "h()" << endl; }
};

class Devired :public Base{
public:
	virtual void x() { cout << "x()" << endl; }
};

int main()
{
	Devired t;
	(((void(*)())   *((int*)(*((int*)&t)))))   ();
	(((void(*)())*((int*)(*((int*)&t)) + 1)))     ();
	(((void(*)())*((int*)(*((int*)&t)) + 2)))     ();

	(((void(*)())*((int*)(*((int*)&t)) + 3)))     ();
}
```
#### 派生类 覆盖 基类虚函数
1）虚表中派生类覆盖的虚函数的地址被放在了基类相应的函数原来的位置 （显然的，不然虚函数失去意义）
2）派生类没有覆盖的虚函数延用基类的
```cpp
class Base {
public:
	virtual void f() { cout << "f()" << endl; }
	virtual void g() { cout << "g()" << endl; }
	virtual void h() { cout << "h()" << endl; }
};
class Derive :public Base{
public:
	virtual void x() { cout << "x()" << endl; }
	virtual void f() { cout << "Derive::f()" << endl; }
};
int main()
{
	Derive t;
	(((void(*)())   *((int*)(*((int*)&t)))))   ();
	(((void(*)())*((int*)(*((int*)&t)) + 1)))     ();
	(((void(*)())*((int*)(*((int*)&t)) + 2)))     ();
	(((void(*)())*((int*)(*((int*)&t)) + 3)))     ();
}
```

### 多继承 + 虚函数表
